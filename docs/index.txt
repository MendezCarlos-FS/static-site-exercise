2:I[5250,["250","static/chunks/250-d036c73339ac4e71.js","931","static/chunks/app/page-979e2d18c98cee17.js"],""]
6:"$Sreact.suspense"
7:I[5613,[],""]
8:I[1778,[],""]
3:T1d67,<p>Hello to any and all who stumble across this post! Hope your day has been going as well, and hope any other days coming up are just as well or better, and if not, I do hope things improve soon!<br>This month, I went over two classes. The one I'll cover in this post will be about the database class I took, but there will be another post talking about the second class as well! Hopefully this sentence will link to that post once it's up!</p><h3>Overview</h3><p>So, what did I learn this time with regards to databases? Well, a decent amount, I'd like to think. The class has us host a virtual machine using AWS's EC2 service (<a href='https://aws.amazon.com/ec2/' target='_blank'>Here's the link for the service</a> in case of curiosity, I feel I don't know enough to properly describe it myself). This instance was created with MySQL and MongoDB installed. We used Mac's Terminal software to communicate with the VM, Filezilla (<a href='https://filezilla-project.org/' target='_blank'>here's a link to Filezilla</a>, which is a software that facilitates file transferring from one's PC to another device like an Amazon-hosted VM!) to transfer files to and from the VM and MySQL Workbench (<a href='https://www.mysql.com/products/workbench/' target='_blank'>here's a link to MySQL Workbench</a>, which is a way to work with MySQL databases in a more visual way than Mac Terminal or just command prompt itself) to work with the MySQL database with a GUI, which I personally prefer. We also worked with MongoDB, a non-relational database (which I'll cover in a moment, and also <a href='https://www.mongodb.com/' target='_blank'>here's a link to MongoDB's site</a> and <a href='https://www.mongodb.com/products/tools/compass' target='_blank'>another link to MongoDB compass</a> which is a GUI interface for it) and Neo4J, a graph-based database system (<a href='https://neo4j.com/' target='_blank'>here's a link to their page</a>). So, here are the things that stuck with me the most for this class:<h3>MySQL</h3><h4>What is it?</h4><p>MySQL is a relational database. My understanding of a relational database is basically creating relationships between different objects. For example, let's say we have a Person table. A person can have something like a Car. The Car has its own set of values, like make, brand, model, etc. You would store the Car's values in its own table, then have the Person store a value from Car that can connect to it, something like an ID, so you wouldn't need to store all of the Car's values into the Person itself. Essentially, you have one Car object in the Car table that the Person table can link to. Since less actual values are being saved, it helps in terms of storage capacity.</p><h4>Why use it?</h4><p>Relational databases in general have been around for the longest time, making them one if not the most common type of database to work with, so learning about any type of relational database is always something good to keep in mind, in my eyes. As such, there's also a huge amount of resource to learn from. Personally coming from a more JSON-oriented mindset when it comes to data, it took some time for me to wrap my head around, even though it was my first type of database interaction ever, but there's no denying its versatility and speed when it comes to handling an enormous amount of data at once.</p><h3>MongoDB</h3><h4>What is it?</h4><p>MongoDB is a non-relational database. This means that each table does not reference another table as the default behavior. So, imagine the same Person table from before that would contain all the information related to the Car table from before stored within it. Another difference is how a non-relational database can have different variable for each object. For example, Person A has an age value whereas Person B has a middle name value instead. These differences can be stored without causing any problems as there is no specific structure associated to the MongoDB databases. They're most closely associated as a JSON object, but in database form. The reason I specify 'as the default behavior' is because it can be programmed to function in a similar manner as relational databases. There is a function for the mongoose module that is utilized in NodeJS, for example, that can populate something like a 'car' variable for a Person that is stored in a Car table instead, which is a function called Populate. I'll go more into NodeJS on my other post once it's uploaded, though!</p><h4>Why use it?</h4><p>To me, the way MongoDB stores objects and retrieves them to and from a database makes more sense. It's more intuitive to me as it's basically just storing JSON objects into a database that we're just retrieving, which makes it much easier to think about. As for speed compared to MySQL, I wouldn't be able to say how much better or worse it is, as I have yet to experience a situation where speed is a necessity, since I do not have actual work experience with regards to thousands of people fetching data from a database. So for my own purposes, I'm currently more inclined to go with MongoDB as a first choice.</p><h3>Neo4J</h3><h4>What is it?</h4><p>Neo4J is a graph database. We didn't cover it as much as the other two, but here's about what I can remember from it. Data is stored same as any other database, but the objects and their relationships are visualized in a graph. The relationships between objects are also shown in this graph manner. This can look something similar to 'Person A --- has a ---> Car A', for example. It's a much easier way to visualize objects and the relationships they have with any other object that exists in the database.</p><h4>Why use it?</h4><p>This was the first time I had heard of Neo4J, and I haven't heard of it being used in a work environment (although it more than likely is), but off the top of my head, the main benefit I can see from it is how easy it is to look at stuff at a glance. The connections make a lot more sense, and you can quickly see if the relationships between the objects make sense. Since every object can have it's own type, you can also easily filter for object types, specific objects or specific object relationships. It feels like it would allow for a more human-readable or human-useable experience compared to the previous database types.</p><h3>Conclusion</h3><p>A lot of info for this class, and personally very useful. I'm hoping I can actually start using one of these for my own personal projects to practice with. I've been using a new software called Obsidian (<a href='https://obsidian.md/' target='_blank'>here's a link to their page</a>), which is basically a text editor that is written mostly in markdown. It allows for a lot of customization that makes it super useful for documentation purposes (at least for my needs), and I'm wondering if I could potentially implement databases to work along with Obsidian. I'd have to program a working plugin with it, or find an existing one if it does exist, so I'm not in a rush to go for it, but it's a nice option to consider. Databases feel like a completely different beast in terms of programming, very useful but very scary at the same time, since a lot of important information can be stored in it and potentially lost if you're not careful. Still, if it weren't useful, it wouldn't be around after decades in different forms to suit ever-evolving needs.<br>That's it from me for this post, I hope anyone finds my insights on what I learned here useful! Take care all, and happy coding!</p>4:T16f1,<p>Hello to all! I hope you're having a good day so far, or even a good start of the day! And if not, I hope you things can improve for you soon enough!<br>Along with the Database class I took this month, I also had a back-end related class. Server-side Languages, which includes the likes of NodeJS, Postman and MongoDB. I covered MongoDB in the database post, but I'll be talking about it here with regards to mongoose, an NPM package that makes communication between the Node app and MongoDB much easier.</p><h3>NodeJS</h3><h4>What is it?</h4><p>NodeJS (<a href='https://nodejs.org/en' target='_blank'>here is their website</a>) is "an asynchronous event-driven JavaScript runtime," as their About page describes. It is able to handle multiple user requests, whether it's sending data or receiving data to and from the user. The way I view it is a middleman between the front-end side (a website a user has access to, like Facebook) and the database that stores all the data related to the front-end. The front-end sends something like a "Get all users" request to the NodeJS app, which then interprets this request, fetches the data from the database if it needs to, then returns that data back to the user that sent the request.</p><h4>Why use it?</h4><p>As a middleman that typically a regular user has no way to directly access, it's a good place to validate data, check for authentication, and prevent anything malicious from accessing the database. Of course, that'll always depend on the implementation of the person creating the NodeJS app, but I feel these are reasons that make it so useful for developers. In also helps facilitate the handling of data. Instead of manually inputting any and all data coming to and from the database, the NodeJS app can do that for us instead. We can code a button in the front-end interface that sends the request of whatever thing we want it to do, have the NodeJS read this request then do all that we need it to for us. Feels like without something like this in basically every working website, it would be nightmarish to work with thousands or millions of data requests in days or even hours. Reasons like these I'm so grateful for humans being lazy as hell, always gotta make things easier somehow!</p><h3>Postman</h3><h4>What is it?</h4><p>Postman (<a href='https://www.postman.com/' target='_blank'>here's the link to their page</a>) is a software that can make requests without having to worry about building a front-end to test certain endpoints. So if you're building specifically just a back-end application but need to test it, Postman is perfect for this. It's technically more than just what I describe it to be, but it's certainly my favorite reason to use it.<h4>Why use it?</h4><p>As mentioned before, it eases the process of sending requests since it has the infrastructure built to display any responses in a human-readable way. My understanding is that it basically makes what used to be something like a curl command (in case you haven't heard of curl before, <a href='https://curl.se/' target='_blank'>here's a link to their page</a>) and make it much easier to write the request and read the response along with any status code it might've returned. It even has a function to convert those request you've made into a curl command, interestingly enough. Along with just making these requests, you can also create tests for the requests which are perfect to make sure every endpoint that you create in your back-end works as expected.</p><h3>MongoDB and Mongoose</h3><h4>What are they?</h4><p>MongoDB (<a href='https://www.mongodb.com/' target='_blank'>here's a link to their page</a>) is a non-relational database. This means that it's a database where the objects stored are not stored with any relationships to each other. They're essentially JSON objects stored in a database. Mongoose (<a href='https://mongoosejs.com/' target='_blank'>here's a link to their documentation</a>) is an NPM package that makes it easy to communicate with your NodeJS app as well as the MongoDB database. It has a lot of built-in functionality that makes it easy to use and allows for a very similar experience to actually handling data directly from MongoDB.</p><h4>Why use them?</h4><p>MongoDB, as well as any other database that is used, is useful for storing large chunks of data. Whatever it is you want to store, there's no reason not to use a database that is designed for this kind of behavior. As for mongoose, it makes the process of communicating with the database a lot more manageable than doing so manually. You can create the objects in your NodeJS app that will map directly into a MongoDB object thanks to mongoose as well as handle retrieved MongoDB objects in the same way one would handle a regular JavaScript object. Both of them working together, it's honestly very useful.</p><h3>Conclusion</h3><p>With the database class and this server-side class taken together, I feel I gained a lot of useful information that can help me for my own personal projects as well as just any work environment. Even if I weren't to use the same technologies, having a good grasp of the concepts and overall workflow is always a plus in my eyes. Immediately after finishing the class, I was motivated to take a free Postman course to learn more about its functionality, and I highly recommend doing so if you ever get the chance or want to learn more about it. It's not too long, goes step by step with its features and teaches a lot of useful features that are either time-saving or useful for organization purposes.<br>For any and all who took the time to read through this, thank you so much! I don't have any high hopes of many people coming across these posts, but if even one person benefits from someone who's still learning, that's good enough for me! Take care, and hope you have a good rest of your day!</p>5:T1440,<p>First off, welcome to any who may be reading! I appreciate giving your time just to read over the insight of just another student. Being able to share my learning experiences as a way for me to reflect in the future could also be a useful way to provide someone else's perspective through this journey. Hope you continue to enjoy your time today! This month's class of Interface Programming with the React.js library has come to an end, and with it is a lot of React.js knowledge obtained. I had a good first impression of React and it certainly didn't disappoint. It felt very robust as a frontend library, giving devs a lot of freedom on how they wish to approach certain problems. In this post, I intend on going over some of the more important concepts that stuck with me as well as any React-specific features that I liked.</p><h3>What is React.js?</h3><p>React.js is a frontend library that gives developers the capability to make single-paged applications with small amounts of effort. It has a lot of options for developers to quickly build these from scratch while still being more lightweight than a framework like Angular.</p><h3>Components</h3><p>The idea behind components is simple, but very effective. Basically, we can take any portion of HTML (whether it's something as simple as a button or more complex like a full page) and make it into its own block of code. So, let's say I want to have a button. With this button, I want to add a few extra things to it, like maybe a dropdown arrow to make a specific selection aside from just a confirmation. I can create this button's behavior and styling inside a Button component, then reuse this block of code by simply referencing this Button component in different parts of the code. The reusability makes it very easy to use common functionality all over the website and only need to update in one location for all of the instances of it to also be updated. A huge time saver and in my mind a good way to think about chunks of HTML.</p><h3>Props and States</h3><p>Props are a way to relay information from a parent component to a child component. Let's say you have a Checkout Page component that contains a Button component. You can send the Button component what text to display within the Checkout Page component as a prop. Then the Button component reads this prop object to get the text and display it.<br>React uses states for each component to keep track of any relevant information. For example, if you have a form that a user will fill up with some information, like a job application form, you can store the information that is being inputted and use it where necessary. Each component can have its own specific state that is unrelated to other components, making it easy to keep track of each individual component's state.<br>Both of these can work together to relay information to other components and/or store the information for future use.</p><h3>Routing</h3><p>Routing allows single-paged applications to traverse through separate page components similar to how one would traverse a traditional website. For example, in a traditional website, you can click the About page from the Home page which will redirect you over to that page. However, it would move you to that page while having to fetch whatever new files are located in that web address. Because of React's single-paged nature, we can use routing to perform the same task without the page refreshing, which means there's no re-fetching of files. I like to think of it as if each page is treated like a quick-swappable block of HTML.</p><h3>Hooks</h3><p>To my understanding, hooks are a React-specific way of handling common behavior. So for example, before you would use a state object in a component to keep track of that component's relevant information. However, you can instead use the useState hook so it can handle most of the logic with regards to actually storing a specific state value for you.<br>The useContext hook can allow parent components to share objects to deeply-nested children components without having to pass it down with each child component. Imagine Component A is a parent component, Component B is a child of A, Component C is a child of B and Component D is a child of C. With useContext, you can directly access a value of Component A from Component D without having to pass it through Component B and Component C.<br>There are many React hooks, each with its own specific use case, but these two are the ones I enjoyed using the most, and thought to share it.</p><h3>Conclusion</h3><p>React.js has a lot of functionality, way more than I covered here, but I wanted to highlight the ones I remember and enjoyed implementing the most. I had previous Angular experience, so a lot of the concepts were the same in both, just the execution of it was different. Of the two, React.js feels much easier to learn in comparison and still provides most of the functionality any single-page application dev is likely to use. I would highly recommend learning React.js as a starting point to the single-paged library/framework concepts over the two, which can help to then transition to the other in case it's necessary.</p>0:["usOlQznC8xtORN901ubbd",[[["",{"children":["__PAGE__",{}]},"$undefined","$undefined",true],["",{"children":["__PAGE__",{},["$L1",["$","main",null,{"className":"flex flex-col items-center justify-between p-5 gap-10","children":[["$","h1",null,{"children":"Available Posts"}],[["$","$L2",null,{"className":"border-2 border-black rounded p-5","href":{"pathname":"/post","query":{"title":"<h2>Database Learning with MongoDB and MySQL!</h2>","body":"$3"}},"dangerouslySetInnerHTML":{"__html":"<div><h2>Database Learning with MongoDB and MySQL!</h2></div>"}}],["$","$L2",null,{"className":"border-2 border-black rounded p-5","href":{"pathname":"/post","query":{"title":"<h2>NodeJS, Postman and MongoDB - Oh My!</h2>","body":"$4"}},"dangerouslySetInnerHTML":{"__html":"<div><h2>NodeJS, Postman and MongoDB - Oh My!</h2></div>"}}],["$","$L2",null,{"className":"border-2 border-black rounded p-5","href":{"pathname":"/post","query":{"title":"<h2>Reflecting on my React.js Learning Experience</h2>","body":"$5"}},"dangerouslySetInnerHTML":{"__html":"<div><h2>Reflecting on my React.js Learning Experience</h2></div>"}}]]]}],null]]},[null,["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__className_6952d4 mx-auto max-w-5xl","children":[["$","header",null,{"children":["$","nav",null,{"className":"flex justify-evenly","children":["$","$L2",null,{"href":"/","children":"Home"}]}]}],["$","$6",null,{"children":["$","$L7",null,{"parallelRouterKey":"children","segmentPath":["children"],"loading":"$undefined","loadingStyles":"$undefined","loadingScripts":"$undefined","hasLoading":false,"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"styles":null}]}],["$","footer",null,{"className":"bottom-0","children":[["$","h4",null,{"children":"Made with Next.js"}],["$","h4",null,{"children":"Made by Carlos Mendez"}]]}]]}]}],null]],[[["$","link","0",{"rel":"stylesheet","href":"/static-site-exercise/_next/static/css/10b4c4e97f75cc22.css","precedence":"next","crossOrigin":""}]],"$L9"]]]]
9:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Static Site Exercise"}],["$","meta","3",{"name":"description","content":"A basic static site made with Next.js"}],["$","link","4",{"rel":"icon","href":"/static-site-exercise/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
1:null
